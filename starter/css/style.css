/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/* By default, browsers apply some margin
or padding. We set these to 0 to ensure the
same starting point for all browsers */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Properties related to font are usually inherited,
so we set these in the body */
body {
  font-family: "Lato", sans-serif;
  font-weight: 400; /* normal */
  font-size: 16px;
  line-height: 1.7;
  color: #777;
  padding: 30px;
}

.header {
  height: 95vh;
  /* First bg image goes on top of second */
  background-image: linear-gradient(
    to right bottom,
  rgba(126, 213, 111, 0.8),
  rgba(40, 180, 133, 0.8)),
  url(../img/hero.jpg);
  background-size: cover;
  background-position: top;

  /* Remove part of the box. what we pass to polygon is what's drawn.
  Coordinates given are for top left, tr, br, bl corners of our shape.
  The grid is the element this is in (header here). x increases to right
  and y increases down, so 0 0 is top left corner of element*/
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  position: relative; /* since we have a child positioned absolutely */
}

.logo-box {
  position: absolute;
  top: 40px;
  left: 40px;
}

.logo {
  height: 35px;
}

.text-box {
  /* center within header */
  position: absolute;
  top: 50%;
  left: 50%;
  /* shift the left and top by -50% relative to the
  width of the text box itself. this will make it so the text box is
  centered */
  transform: translate(-50%, -50%);
  /* center inline/inline-block child elements (which are treated as text) */
  text-align: center;
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;

  /* fix the shaking up/down in animations.
  no one knows why shaking happens or why this fixes it */
  backface-visibility: hidden;
  margin-bottom: 60px;
}

.heading-primary-main {
  /* Spans are inline elements by default, but we want
  our main and sub to be block so they get their own line
  and take up full width available to them */
  display: block;
  font-size: 60px;
  font-weight: 400;
  letter-spacing: 35px;

  animation-name: moveInFromLeft;
  animation-duration: 1s;
  animation-timing-function: ease-out;

  /* other anim props we could use:
  animation-iteration-count: 3;
  animation-delay: 3s; */
}

.heading-primary-sub {
  display: block;
  font-size: 20px;
  font-weight: 700;
  letter-spacing: 17.4px;

  /* shorthand for name, duration, timing */
  animation: moveInFromRight 1s ease-out;
}

/* browsers are optimized to animate transform and opacity */
@keyframes moveInFromLeft {
  0% {
    opacity: 0;
    transform: translateX(-100px);
  }

  80% {
    transform: translateX(10px);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

@keyframes moveInFromRight {
  0% {
    opacity: 0;
    transform: translateX(100px);
  }

  80% {
    transform: translateX(-10px);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

@keyframes moveInFromBottom {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

/* make button look same before and after it's clicked */
.btn:link,
.btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  display: inline-block;
  border-radius: 100px;

  /* needs to be on initial state, link, to animate.
  now property changes, like the ones below using transform,
  will happen smoothly vs. abruptly */
  transition: all 0.2s;
  position: relative;
}

.btn:hover {
  /* translate arg is relative to btn link state */
  transform: translateY(-3px);

  /* x offset, y offset, blur, color. higher blur 
  makes shadowed element look farther away */
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

/* while btn is pressed down */
.btn:active {
  transform: translateY(-1px);
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
}

.btn-white {
  background-color: #fff;
  color: #777;
  padding: 15px 40px;
}

.btn::after {
  /* pseudoelement must have content and display prop to appear
  we copy and put it behind the actual btn. actual btn remains
  on top always. */
  content: "";
  display: inline-block;
  height: 100%;
  width: 100%;
  border-radius: 100px;
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  transition: all 0.4s;
}

.btn-white::after {
  background-color: #fff;
}

/* will apply the after we defined above on hover
  initial state for this is the 'after' pseudoelement */
.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6);
  opacity: 0;
}

.btn-animated {
  animation: moveInFromBottom 0.5s ease-out 0.75s;
  /* fill-mode backwards applies styles of 0% keyframe before animation starts */
  animation-fill-mode: backwards;
}