/* browsers are optimized to animate transform and opacity */
@keyframes moveInFromLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem); }
  80% {
    transform: translateX(1rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

@keyframes moveInFromRight {
  0% {
    opacity: 0;
    transform: translateX(10rem); }
  80% {
    transform: translateX(-1rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

@keyframes moveInFromBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

/* By default, browsers apply some margin
or padding. We set these to 0 to ensure the
same starting point for all browsers.
This is called a global reset. */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit; }

/* Set root font size to 10px so rem is just x10 */
html {
  font-size: 62.5%; }

body {
  box-sizing: border-box; }

/* Properties related to font are usually inherited,
so we set these in the body */
body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* normal */
  line-height: 1.7;
  color: #777;
  padding: 3rem; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  /* fix the shaking up/down in animations.
  no one knows why shaking happens or why this fixes it */
  backface-visibility: hidden;
  margin-bottom: 6rem; }
  .heading-primary--main {
    /* Spans are inline elements by default, but we want
    our main and sub to be block so they get their own line
    and take up full width available to them */
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    animation-name: moveInFromLeft;
    animation-duration: 1s;
    animation-timing-function: ease-out;
    /* other anim props we could use:
    animation-iteration-count: 3;
    animation-delay: 3s; */ }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    /* shorthand for name, duration, timing */
    animation: moveInFromRight 1s ease-out; }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  display: inline-block;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  /* clips the bg image to the text, so the gradient is only visible where text is,
  but we then need to set the text transparent so the linear-gradient color takes effect */
  -webkit-background-clip: text;
  color: transparent;
  letter-spacing: .2rem;
  transition: all .2s; }
  .heading-secondary:hover {
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

.u-center-text {
  text-align: center; }

.u-margin-bottom-small {
  margin-bottom: 1.5rem; }

.u-margin-bottom-medium {
  margin-bottom: 4rem; }

.u-margin-bottom-big {
  margin-bottom: 8rem; }

.btn {
  /* make button look same before and after it's clicked */
  /* while btn is pressed down */ }
  .btn:link, .btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    display: inline-block;
    border-radius: 10rem;
    /* needs to be on initial state, link, to animate.
      now property changes, like the ones below using transform,
      will happen smoothly vs. abruptly */
    transition: all .2s;
    position: relative;
    font-size: 1.6rem; }
  .btn:hover {
    /* translate arg is relative to btn link state */
    transform: translateY(-0.3rem);
    /* x offset, y offset, blur, color. higher blur 
      makes shadowed element look farther away */
    box-shadow: 0 0.1rem 0.2rem rgba(0, 0, 0, 0.2);
    /* will apply the after we defined above on hover
      initial state for this is the 'after' pseudoelement */ }
    .btn:hover::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0; }
  .btn:active {
    transform: translateY(-0.1rem);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); }
  .btn--white {
    background-color: #fff;
    color: #777;
    padding: 1.5rem 4rem; }
    .btn--white::after {
      background-color: #fff; }
  .btn::after {
    /* pseudoelement must have content and display prop to appear
      we copy and put it behind the actual btn. actual btn remains
      on top always. */
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transition: all .4s; }
  .btn--animated {
    animation: moveInFromBottom .5s ease-out .75s;
    /* fill-mode backwards applies styles of 0% keyframe before animation starts */
    animation-fill-mode: backwards; }

.btn-text:link, .btn-text:visited {
  font-size: 1.6rem;
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  /* transition needs to be on link */
  transition: all .2s; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px); }

.btn-text:active {
  transform: translateY(0); }

.composition {
  position: relative;
  /* When hover on composition, select photos that aren't hovered */ }
  .composition__photo {
    /* flexible images: define width as % if possible so it scales w/ viewport */
    width: 55%;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    border-radius: 2px;
    position: absolute;
    z-index: 10;
    transition: all .2s;
    outline-offset: 2rem; }
    .composition__photo--p1 {
      left: 0;
      top: -2rem; }
    .composition__photo--p2 {
      right: 0;
      top: 2rem; }
    .composition__photo--p3 {
      left: 20%;
      top: 10rem; }
    .composition__photo:hover {
      outline: 1.5rem solid #55c57a;
      transform: scale(1.05) translateY(-0.5rem);
      box-shadow: 0 2.5rem 4rem rgba(0, 0, 0, 0.5);
      z-index: 20; }
  .composition:hover .composition__photo:not(:hover) {
    transform: scale(0.95); }

.feature-box {
  background-color: rgba(255, 255, 255, 0.8);
  font-size: 1.5rem;
  padding: 2.5rem;
  text-align: center;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition: transform .3s; }
  .feature-box__icon {
    font-size: 6rem;
    margin-bottom: .5rem;
    display: inline-block;
    background-image: linear-gradient(to right, #7ed56f, #28b485);
    /* Icon font behaves as text so same declarations from _typography are used */
    -webkit-background-clip: text;
    color: transparent; }
  .feature-box:hover {
    transform: translateY(-1.5rem) scale(1.03); }

.row {
  /* 1140 px used as standard max grid width */
  max-width: 114rem;
  /* center block el inside another block el */
  margin: 0 auto;
  /* select everything except last child */
  /* selects all els that have class attr beginning with 'col-' */ }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    content: "";
    display: table;
    clear: both; }
  .row [class^="col-"] {
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    /* In native CSS calc() you can mix units, but not in SCSS's version
    These calculations have to occur when page is about to rendered
    in user's browser. Must wrap our Sass var using hash and brackets */
    width: calc(1/2 * (100% - 6rem)); }
  .row .col-1-of-3 {
    width: calc(1/3 * (100% - 2 * 6rem)); }
  .row .col-2-of-3 {
    width: calc(2/3 * (100% - 2 * 6rem) + 6rem); }
  .row .col-1-of-4 {
    width: calc(1/4 * (100% - 3 * 6rem)); }
  .row .col-2-of-4 {
    width: calc(2/4 * (100% - 3 * 6rem) + 6rem); }
  .row .col-3-of-4 {
    width: calc(3/4 * (100% - 3 * 6rem) + 2 * 6rem); }

.header {
  height: 95vh;
  /* First bg image goes on top of second */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  /* Remove part of the box. what we pass to polygon is what's drawn.
  Coordinates given are for top left, tr, br, bl corners of our shape.
  The grid is the element this is in (header here). x increases to right
  and y increases down, so 0 0 is top left corner of element*/
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  position: relative;
  /* since we have a child positioned absolutely */ }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    left: 4rem; }
  .header__logo {
    height: 3.5rem; }
  .header__text-box {
    /* center within header */
    position: absolute;
    top: 50%;
    left: 50%;
    /* shift the left and top by -50% relative to the
    width of the text box itself. this will make it so the text box is
    centered */
    transform: translate(-50%, -50%);
    /* center inline/inline-block child elements (which are treated as text) */
    text-align: center; }

.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  /* negative margin-top causes it to move up
  and be overlapped by the header above */
  margin-top: -20vh; }

.section-features {
  padding: 20rem 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/nat-4.jpg);
  background-size: cover;
  transform: skewY(-7deg);
  margin-top: -10rem;
  /* select all direct children of this section */ }
  .section-features > * {
    transform: skewY(7deg); }
